@using System
@using System.Threading
@using System.Text.RegularExpressions
@using FWO.Ui.Data
@using FWO.Report
@using FWO.Report.Filter
@using FWO.Ui.Pages.Reporting.Reports
@using FWO.Api.Data
@using FWO.Middleware.Client

@page "/certification"

@inject ApiConnection apiConnection
@inject UserConfig userConfig
@inject MiddlewareClient middlewareClient

@* ==== LEFT SIDEBAR ==== *@
<Sidebar @ref="deviceSelectionSidebar" Collapsible="true" Resizeable="true" PositionLeft="true" @bind-Width="sidebarLeftWidth">
    <br>
    <div class="btn-group sticky-marker pl-3 pr-3 w-100">
        @if (processing == false)
        {
            <button class="btn btn-sm btn-primary" @onclick="() => GenerateRecertificationReport()">@(userConfig.GetText("load_rules"))</button>
        }
        else
        {
            <button class="btn btn-sm btn-danger" @onclick="() => CancelGeneration()">@(userConfig.GetText("stop_fetching"))</button>
        }
        <br>
    </div>
    <div class="p-3">
        <h5 class="text-left">@(userConfig.GetText("due_within")):</h5>
        <input  type="text" class="form-control form-control-sm" @bind="recertLookAheadDays" />
    </div>

    <AuthorizeView Roles="admin, auditor">
        <Authorized>
            <div class="p-3">
                <h7 class="text-left">@(userConfig.GetText("owner"))</h7>
                <Dropdown ElementType="FwoOwner" ElementToString="@(o => o.Name)"
                    Value="selectedOwner" ValueChanged="OwnerChanged" Elements="ownerList">
                    <ElementTemplate Context="owner">
                        @owner.Name
                    </ElementTemplate>
                </Dropdown>
                @if (selectedOwner.Name != "")
                {
                    recertWithoutOwner = false;
                }
                <br>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="recertOverdue"
                        @bind="recertOverdueOnly"
                        @oninput="@(async () => { recertOverdueOnly = !recertOverdueOnly; SyncFilterToDisplay(); })" />
                    <label class="form-check-label" for="recertOverdue">@(userConfig.GetText("overdue_recert"))</label>
                </div>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="recertWithoutOwner"
                        @bind="recertWithoutOwner"
                        @oninput="@(async () => { 
                            recertWithoutOwner = !recertWithoutOwner;
                            if (recertWithoutOwner)
                            {
                                selectedOwner = new FwoOwner();
                                OwnerChanged(selectedOwner);
                                StateHasChanged();
                            }
                        })" />
                    <label class="form-check-label" for="recertWithoutOwner">@(userConfig.GetText("without_owner"))</label>
                </div>
            </div>
        </Authorized>
        <NotAuthorized>
            @if(collectedOwnerships.Count > 1)
            {
                <h7 class="text-left">@(userConfig.GetText("owner"))</h7>
                <Dropdown ElementType="FwoOwner" ElementToString="@(o => o.Name)"
                    Value="selectedOwner" ValueChanged="OwnerChanged" Elements="collectedOwnerships">
                    <ElementTemplate Context="owner">
                        @owner.Name
                    </ElementTemplate>
                </Dropdown>
            }
        </NotAuthorized>
    </AuthorizeView>

    <DeviceSelection Environment="Cert" @bind-DeviceFilter="deviceFilter" @bind-CollapseAll="collapseDevices" @bind-FilterInput="filterInput" @bind-SelectAll="selectAll" ></DeviceSelection>
</Sidebar>

@* ==== MAIN MIDDLE SECTION ==== *@

<div style="margin-left: @($"{sidebarLeftWidth + 10}px"); margin-right: @($"{sidebarRightWidth + 10}px");">
    <h3>@(userConfig.GetText("recertification"))</h3>
    <div class="btn-group sticky-marker-60">
        @if(!readonlyMode)
        {
            <AuthorizeView Roles="admin, recertifier">
                <Authorized>
                    @if(rulesFound)
                    {
                        <button class="btn btn-sm btn-danger" @onclick="() => RequestExecuteSelected()">@(userConfig.GetText("execute_selected"))</button>
                    }
                    else
                    {
                        <button class="btn btn-sm btn-danger" disabled>@(userConfig.GetText("execute_selected"))</button>
                    }
                </Authorized>
                <NotAuthorized>
                    <button class="btn btn-sm btn-danger" disabled>@(userConfig.GetText("execute_selected"))</button>
                </NotAuthorized>
            </AuthorizeView>
        }
    </div>
    <hr />
    <RulesReport Recertification="true" ReadonlyMode="readonlyMode" Managements="managements" RulesPerPage="rulesPerPage" 
        ReportParams="reportParams"
        @bind-SelectedRules="selectedRules">
    </RulesReport>
</div>

<PopUp Title="@(userConfig.GetText("add_comment"))" Show="@AddCommentMode" Large="true" OnClose="() => AddCommentMode = false">
    <Body>
        @if (AddCommentMode)
        {
            <form onsubmit="return false">
                <div class="form-group row">
                    <label for="comment" class="col-sm-2 col-form-label col-form-label-sm">@(userConfig.GetText("comment") + (userConfig.CommentRequired ? "*:" : ":"))</label>
                    <div class="col-sm-8">
                        <input id="comment" type="text" class="form-control form-control-sm" @bind="actComment" />
                    </div>
                </div>
            </form>
        }
    </Body>
    <Footer>
        <div class="btn-group">
            <button class="btn btn-sm btn-primary" @onclick="() => ExecuteSelected()">@(userConfig.GetText("ok"))</button>
            <button class="btn btn-sm btn-secondary" @onclick="Cancel">@(userConfig.GetText("cancel"))</button>
        </div>
    </Footer>
</PopUp>

@*==== RIGHT SIDEBAR ====*@
<Sidebar Collapsible="true" Resizeable="true" PositionLeft="false" @bind-Width="sidebarRightWidth">
    <div class="p-3">
        <h5 class="text-center">@(userConfig.GetText("objects"))</h5>

        <CascadingValue Value="anchorNavToRSB">
            <TabSet KeepPanelsAlive="true" @ref="rsbTabset">
                <Tab Title="Report">
                    <div class="d-md-flex justify-content-md-end sticky-marker-45 bg-white">
                        <div class="btn btn-secondary btn-sm w-50" @onclick="@(() => collapseControlObjects.CollapseAll())">@(userConfig.GetText("collapse_all"))</div>
                    </div>
                    <div class="mt-2">
                        <CascadingValue Value="collapseControlObjects">
                            <ObjectGroupCollection FetchObjects="FetchContent" Recert="true" Tab="report" InputDataType="Management" Data="managements.Where(m => (m.Devices.Where(d => d.Rules != null && d.Rules.Count() > 0).Count() > 0))" NameExtractor="man => man.Name"
                                                NetworkObjectExtractor="man => man.ReportObjects"
                                                NetworkServiceExtractor="man => man.ReportServices"
                                                NetworkUserExtractor="man => man.ReportUsers" />
                        </CascadingValue>
                    </div>
                </Tab>
                <Tab Title="@(userConfig.GetText("rule"))">
                    <div class="d-md-flex justify-content-md-between sticky-marker-45 bg-white">
                        <div class="btn btn-dark btn-sm w-50" @onclick="@(() => selectedRules.Clear())">@(userConfig.GetText("clear_all"))</div>
                        <div class="btn btn-secondary btn-sm w-50" @onclick="@(() => collapseControlObjects.CollapseAll())">@(userConfig.GetText("collapse_all"))</div>
                    </div>
                    <div class="mt-2">
                        <CascadingValue Value="collapseControlObjects">
                            <ObjectGroupCollection FetchObjects="FetchContent" Recert="false" Tab="rule" StartContentDetailed="true" StartCollapsed="false" InputDataType="Rule" Data="selectedRules"
                                                NameExtractor=@(rule => $"{rule.DeviceName} - Rule {rule.Id} {rule.Name}")
                                                NetworkObjectExtractor="rule => rule.Froms.Select(nl => nl.Object).Union(rule.Tos.Select(nl => nl.Object)).Union(rule.NatData.TranslatedFroms.Select(nl => nl.Object)).Union(rule.NatData.TranslatedTos.Select(nl => nl.Object)).OrderBy(o => o.Name).ToArray()"
                                                NetworkServiceExtractor="rule => rule.Services.Select(sw => sw.Content).Union(rule.NatData.TranslatedServices.Select(sw => sw.Content)).OrderBy(s => s.Name).ToArray()"
                                                NetworkUserExtractor="rule => rule.Froms.Select(nl => nl.User).Distinct().Where(u => u != null).OrderBy(u => u.Name).ToArray()" />
                        </CascadingValue>
                    </div>
                </Tab>
            </TabSet>
        </CascadingValue>
    </div>
</Sidebar>

<AnchorNavToRSB @ref="anchorNavToRSB" TabSet="rsbTabset" />

@code
{
    [CascadingParameter]
    Action<Exception?, string, string, bool> DisplayMessageInUi { get; set; } = DefaultInit.DoNothing;

    [CascadingParameter]
    private Task<AuthenticationState>? authenticationStateTask { get; set; }

    private TabSet? rsbTabset;
    private AnchorNavToRSB? anchorNavToRSB;

    private const int rulesPerPage = 0;

    private int sidebarLeftWidth = GlobalConfig.kSidebarLeftWidth;
    private int sidebarRightWidth = GlobalConfig.kSidebarRightWidth;
    private bool selectAll = true;

    private string filterInput = "remove=false and recertdisplay=30";
    private bool processing = false;
    private bool rulesFound = false;
    private CancellationTokenSource tokenSource = new CancellationTokenSource();
    private bool recertWithoutOwner = false;

    private Management[] managements = new Management[0];
    
    private bool readonlyMode = false;
    public FwoOwner selectedOwner = new FwoOwner();
    private List<FwoOwner> ownerList = new List<FwoOwner>();
    private List<FwoOwner> userOwnerships = new List<FwoOwner>();
    private List<FwoOwner> groupOwnerships = new List<FwoOwner>();
    private List<FwoOwner> collectedOwnerships = new List<FwoOwner>();
    private Dictionary<int, int> recertInterval = new Dictionary<int, int>();
    private DeviceFilter deviceFilter = new DeviceFilter();
    private List<Rule> selectedRules = new List<Rule>();
    private bool collapseDevices = false;
    private CollapseState collapseControlObjects = new CollapseState();

    private ReportBase? currentReport;
    private ReportTemplate reportParams = new ReportTemplate();

    private Sidebar? deviceSelectionSidebar;
    private bool AddCommentMode = false;
    private string actComment = "";
    private bool recertOverdueOnly = false;
    private bool recertShowAnyMatch = true;
    private bool recertSingleLinePerRule = false;
    private int recertLookAheadDays = 0;

    private List<Rule> Certifications = new List<Rule>();
    private Dictionary<int, List<string>> deleteList = new Dictionary<int, List<string>>();

    private TicketCreator ticketCreator;

    private void OwnerChanged(FwoOwner owner)
    {
        selectedOwner = owner;
    }

    protected override async Task OnInitializedAsync()
    {
        try
        {
            rulesFound = false;
            ticketCreator = new TicketCreator(apiConnection, userConfig);

            ownerList = await apiConnection.SendQueryAsync<List<FwoOwner>>(FWO.Api.Client.Queries.OwnerQueries.getOwners);
            await CollectOwnerships();

            deviceFilter.Managements = await apiConnection.SendQueryAsync<List<ManagementSelect>>(DeviceQueries.getDevicesByManagements);
            await InvokeAsync(StateHasChanged);
            if (deviceFilter.NumberMgmtDev() > userConfig.MinCollapseAllDevices)
            {
                collapseDevices = true;
                await InvokeAsync(StateHasChanged);
            }
            recertLookAheadDays = Convert.ToInt32(userConfig.RecertificationDisplayPeriod);
        }
        catch (Exception exception)
        {
            DisplayMessageInUi(exception, userConfig.GetText("object_fetch"), "", true);
        }
    }

    private async Task CollectOwnerships()
    {
        userOwnerships = await apiConnection.SendQueryAsync<List<FwoOwner>>(OwnerQueries.getOwnerIdsForUser, new {userDn = userConfig.User.Dn});
        recertInterval.Add(0, userConfig.RecertificationPeriod);

        List<UserGroup> ownerGroups = await GroupAccess.GetGroupsFromInternalLdap(middlewareClient, userConfig, DisplayMessageInUi, true);
        List<string> ownerGrpDns = new List<string>();
        foreach(var grp in ownerGroups)
        {
            if(grp.Users.FirstOrDefault(x => x.Dn == userConfig.User.Dn) != null)
            {
                ownerGrpDns.Add(grp.Dn);
            }
        }
        if(ownerGrpDns.Count > 0)
        {
            groupOwnerships = await apiConnection.SendQueryAsync<List<FwoOwner>>(OwnerQueries.getOwnerIdsFromGroups, new {groupDns = ownerGrpDns});
        }

        foreach(var owner in userOwnerships)
        {
            collectedOwnerships.Add(owner);
            recertInterval.Add(owner.Id, owner.RecertInterval ?? userConfig.RecertificationPeriod);
        }
        foreach(var owner in groupOwnerships)
        {
            if(collectedOwnerships.FirstOrDefault(x => x.Id == owner.Id) == null)
            {
                collectedOwnerships.Add(owner);
                recertInterval.Add(owner.Id, owner.RecertInterval ?? userConfig.RecertificationPeriod);
            }
        }
        if(collectedOwnerships.Count == 1)
        {
            selectedOwner = collectedOwnerships[0];
        }
    }

    private async Task GenerateRecertificationReport()
    {
        processing = true;
        readonlyMode = !authenticationStateTask!.Result.User.IsInRole("recertifier") || recertWithoutOwner;
        selectedRules.Clear();

        Management[] managementsOrig = managements;
        try
        {
            tokenSource = new CancellationTokenSource();
            var token = tokenSource.Token;

            if (!deviceFilter.isAnyDeviceFilterSet())  // display pop-up with warning
            {
                DisplayMessageInUi(null, userConfig.GetText("no_device_selected"), userConfig.GetText("E1001"), true);
                processing = false;
                return;
            }

            SyncFilterToDisplay();
            RecertFilter recertFilter = new RecertFilter()
            {
                RecertOwnerList = new List<int>() { selectedOwner.Id },
                RecertOverdueOnly = recertOverdueOnly,
                RecertWithoutOwner = recertWithoutOwner,
                RecertShowAnyMatch = recertShowAnyMatch,
                RecertSingleLinePerRule = recertSingleLinePerRule,
                RecertificationDisplayPeriod = recertLookAheadDays
            };
            reportParams = new ReportTemplate("", deviceFilter, (int) ReportType.Recertification, new TimeFilter(), recertFilter);
            currentReport = ReportBase.ConstructReport(reportParams, userConfig);

            DateTime startTime = DateTime.Now;
            managements = new Management[0]; // reset management data when switching between reports

            try
            {
                await currentReport.Generate(userConfig.ElementsPerFetch, apiConnection,
                managementsReportIntermediate =>
                {
                    managements = managementsReportIntermediate;
                    return InvokeAsync(StateHasChanged);
                }, token);
            }
            catch (OperationCanceledException e)
            {
                Log.WriteDebug("Generate Report", $"Cancelled: {e.Message}");
            }

            rulesFound = false;
            foreach (Management management in managements)
                foreach (Device device in management.Devices)
                    if (device.ContainsRules())
                    {
                        rulesFound = true;
                        if (device.Rules != null)
                            foreach (Rule rule in device.Rules)
                                rule.Metadata.UpdateRecertPeriods(userConfig.RecertificationPeriod, userConfig.RecertificationNoticePeriod);
                    }
            processing = false;
            
            await InvokeAsync(StateHasChanged);
            if(!rulesFound)
            {
                DisplayMessageInUi(null, userConfig.GetText("generate_report"), userConfig.GetText("E4002"), true);
            }
        }
        catch (Exception exception)
        {
            processing = false;
            managements = managementsOrig;
            StateHasChanged();
            DisplayMessageInUi(exception, userConfig.GetText("generate_report"), "", true);
        }
    }

    private void CancelGeneration()
    {
        tokenSource.Cancel();
        DisplayMessageInUi(null, userConfig.GetText("report_data_fetch"), userConfig.GetText("E1003"), true);
    }

    private void SyncFilterToDisplay()
    {
        filterInput = Regex.Replace(filterInput, "recertdisplay=" + @"-?\d+", $"recertdisplay={(userConfig.RecertificationPeriod-userConfig.RecertificationDisplayPeriod).ToString()}");
    }

    const byte all = 10, report = 20, rule = 30, all_nobj = 11, all_nsrv = 12, all_user = 13, report_nobj = 21, report_nsrv = 22, report_user = 23;
    public async Task FetchContent(byte contentType, Func<Management[], Task> callback, long id = 0, bool nat = false)
    {
        Log.WriteDebug("Fetching Content..", "");

        Management[] managements = new Management[0];

        try
        {
            string query = "";
            Dictionary<String, object> queryVars = new Dictionary<string, object>();

            bool newObjects = true;
            int fetchCount = 0;

            bool gotAllObjects = true;

            switch (contentType)
            {
                case all:
                    query = ObjectQueries.getAllObjectDetails;
                    break;
                case all_nobj:
                    query = ObjectQueries.getNetworkObjectDetails;
                    break;
                case all_nsrv:
                    query = ObjectQueries.getNetworkServiceObjectDetails;
                    break;
                case all_user:
                    query = ObjectQueries.getUserDetails;
                    break;
                case rule:
                    if (nat)
                        query = RuleQueries.getNatRuleDetails;
                    else
                        query = RuleQueries.getRuleDetails;
                    break;
            }

            switch (contentType)
            {
                case all or all_nobj or all_nsrv or all_user:

                    queryVars = new Dictionary<string, object>()
                    {
                        { "limit", userConfig.ElementsPerFetch },
                        { "offset", 0 },
                        { "management_id", (int) id }
                    };

                    break;

                case report or report_nobj or report_nsrv or report_user:

                    queryVars = new Dictionary<string, object>()
                    {
                        { "limit", userConfig.ElementsPerFetch },
                        { "offset", 0 },
                        { "mgmIds", (int) id }
                    };

                    if (currentReport != null)
                        gotAllObjects = await currentReport.GetObjectsForManagementInReport(queryVars, (byte)(contentType - report), userConfig.AutoFillRightSidebar ? int.MaxValue : userConfig.MaxInitialFetchesRightSidebar, apiConnection, callback);

                    if (!gotAllObjects)
                        DisplayMessageInUi(null, userConfig.GetText("object_fetch_warning"), userConfig.GetText("E0021"), true);

                    return;

                case rule:

                    queryVars = new Dictionary<string, object>()
                    {
                        { "limit", userConfig.ElementsPerFetch },
                        { "offset", (int)0 },
                        { "rule_id", id }
                    };

                    break;
            }

            // lazy fetch all objects for right sidebar
            while (newObjects && (++fetchCount <= userConfig.MaxInitialFetchesRightSidebar || userConfig.AutoFillRightSidebar))
            {
                Management[] managementsCurrentFetch = await apiConnection.SendQueryAsync<Management[]>(query, queryVars);
                if (fetchCount == 1)
                {
                    managements = managementsCurrentFetch;
                }
                else
                {
                    newObjects = managements.Merge(managementsCurrentFetch);
                }

                if (queryVars.ContainsKey("offset"))
                    queryVars["offset"] = (int)queryVars["offset"] + userConfig.ElementsPerFetch;
                await callback(managements);
            }

            Log.WriteDebug("Lazy Fetch", $"Fetched sidebar objects in {fetchCount - 1} cycle(s) ({userConfig.ElementsPerFetch} at a time)");

            if (fetchCount > userConfig.MaxInitialFetchesRightSidebar && !userConfig.AutoFillRightSidebar)
                DisplayMessageInUi(null, userConfig.GetText("object_fetch_warning"), userConfig.GetText("E0021"), true);
        }
        catch (Exception exception)
        {
            DisplayMessageInUi(exception, userConfig.GetText("object_fetch"), "", true);
            // TODO: Error Interface for all Components, that enables displaying a message in the ui
        }
    }

    private void RequestExecuteSelected()
    {
        AddCommentMode = true;
    }

    private void Cancel()
    {
        AddCommentMode = false;
    }

    private async Task ExecuteSelected()
    {
        bool shortened = false;
        actComment = Sanitizer.SanitizeMand(actComment, ref shortened);
        if(shortened)
        {
            DisplayMessageInUi(null, userConfig.GetText("execute_selected"), userConfig.GetText("U0001"), true);
        }
        if(userConfig.CommentRequired && actComment == "")
        {
            DisplayMessageInUi(null, userConfig.GetText("execute_selected"), userConfig.GetText("E4001"), true);
            return;
        }
        AddCommentMode = false;
        try
        {
            AnalyzeSelected();
            await DoRecerts();

            // create delete tickets
            foreach(var device in deleteList)
            {
                await ticketCreator.CreateRuleDeleteTicket(device.Key, device.Value, actComment, DateTime.Now.AddDays(userConfig.RuleRemovalGracePeriod));
            }

            // reload updated report
            await GenerateRecertificationReport();
        }
        catch (Exception exception)
        {
            DisplayMessageInUi(exception, userConfig.GetText("execute_selected"), "", true);
        }
    }

    private void AnalyzeSelected()
    {
        // collect selected recerts + decerts
        Certifications = new List<Rule>();

        foreach (Management management in managements)
        {
            foreach (Device device in management.Devices)
            {
                if(device.Rules != null)
                {
                    foreach (Rule rule in device.Rules)
                    {
                        // await InitRecert(rule); // just for test
                        if(rule.Metadata.Recert || rule.Metadata.ToBeRemoved)
                        {
                            rule.DeviceId = device.Id;
                            Certifications.Add(rule);
                        }
                    }
                }
            }
        }
    }

    private async Task DoRecerts()
    {
        int recerts = 0;
        int decerts = 0;
        deleteList = new Dictionary<int, List<string>>();

        if (Certifications.Count > 0)
        {
            foreach(var certRule in Certifications)
            {
                if(await Recertify(certRule))
                {
                    if(certRule.Metadata.Recert)
                    {
                        recerts++;
                    }
                    else
                    {
                        decerts++;
                        if(await checkAllDecertified(certRule))
                        {
                            if(!deleteList.ContainsKey(certRule.DeviceId))
                            {
                                deleteList.Add(certRule.DeviceId, new List<string>());
                            }
                            deleteList[certRule.DeviceId].Add(certRule.Uid ?? "");
                        }
                    }
                }
            }
        }
        string txt = userConfig.GetText("recerts_executed") + recerts.ToString() + ", " +
                        userConfig.GetText("decerts_executed") + decerts.ToString();
        DisplayMessageInUi(null, userConfig.GetText("execute_selected"), txt, false);
    }

    private async Task<bool> checkAllDecertified(Rule rule)
    {
        var variables = new
        {
            ruleId = rule.Id,
        };
        return ((await apiConnection.SendQueryAsync<List<Recertification>>(RecertQueries.getOpenRecertsForRule, variables)).Count == 0);
    }

    private async Task<bool> Recertify(Rule rule)
    {
        var variables = new
        {
            ruleId = rule.Id,
            ownerId = selectedOwner.Id,
            userDn = userConfig.User.Dn,
            recertified = rule.Metadata.Recert,
            recertDate = DateTime.Now,
            comment = actComment
        };
        bool recertOk = (await apiConnection.SendQueryAsync<ReturnId>(RecertQueries.recertify, variables)).AffectedRows > 0;
        if(recertOk && rule.Metadata.Recert)
        {
            await InitRecert(rule);
        }
        return recertOk;
    }

    private async Task InitRecert(Rule rule)
    {
        var prepvariables = new
        {
            ruleMetadataId = rule.Metadata.Id,
            ruleId = rule.Id,
            ipMatch = rule.IpMatch,
            ownerId = selectedOwner.Id,
            nextRecertDate = DateTime.Now.AddDays(recertInterval[selectedOwner.Id])
        };
        await apiConnection.SendQueryAsync<object>(RecertQueries.prepareNextRecertification, prepvariables);
    }
}
