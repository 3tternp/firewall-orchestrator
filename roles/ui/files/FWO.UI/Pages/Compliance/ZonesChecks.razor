@using NetTools;

@page "/compliance/zones/checks"

@layout ComplianceLayout

@inject UserConfig userConfig
@inject NetworkZoneService networkZoneService

<h3>@userConfig.GetText("network_zone_check")</h3>

<form>
	<div class="form-group row">
		<label class="col-sm-1 col-form-label">@userConfig.GetText("from")</label>
		<div class="col-sm-11">
			<IpAddressInput @bind-IpRange="sourceIpRange" />
		</div>
	</div>
	<div class="form-group row">
		<label class="col-sm-1 col-form-label">@userConfig.GetText("to")</label>
		<div class="col-sm-11">
			<IpAddressInput @bind-IpRange="destinationIpRange" />
		</div>
	</div>
	<div class="form-group row">
		<div class="col-sm-2">
			<button @onclick="CheckIpRangeInputCompliance" type="button" class="btn btn-primary">@userConfig.GetText("check")</button>
		</div>
		<div class="col-sm-10">
			<label>@output</label>
		</div>
	</div>
</form>

@code 
{
	IPAddressRange? sourceIpRange;
	IPAddressRange? destinationIpRange;
	string output = "";

	private void CheckIpRangeInputCompliance()
	{
		if (sourceIpRange != null && destinationIpRange != null)
		{
			bool compliant = CheckCompliance
			(
				new List<IPAddressRange>() { sourceIpRange },
				new List<IPAddressRange>() { destinationIpRange },
				out List<(ComplianceNetworkZone, ComplianceNetworkZone)> forbiddenCommunication
			);

			output = $"Compliant: {compliant}. ";
			if (!compliant)
			{
				output += $"Violations: {string.Join(", ", forbiddenCommunication.ConvertAll(x => $"{x.Item1.Name} to {x.Item2.Name}"))}";
			}
		}
	}

	private bool CheckRuleCompliance(Rule rule, out List<(ComplianceNetworkZone, ComplianceNetworkZone)> forbiddenCommunication)
	{
		List<IPAddressRange> froms = new List<IPAddressRange>();
		List<IPAddressRange> tos = new List<IPAddressRange>();

		foreach (NetworkLocation networkLocation in rule.Froms)
		{
			// Determine all source ip ranges
			froms.AddRange(ParseIpRange(networkLocation.Object));
		}
		foreach (NetworkLocation networkLocation in rule.Tos)
		{
			// Determine all destination ip ranges
			tos.AddRange(ParseIpRange(networkLocation.Object));
		}

		return CheckCompliance(froms, tos, out forbiddenCommunication);
	}

	private bool CheckCompliance(List<IPAddressRange> source, List<IPAddressRange> destination, out List<(ComplianceNetworkZone, ComplianceNetworkZone)> forbiddenCommunication)
	{
		// Determine all matching source zones
		List<ComplianceNetworkZone> sourceZones = DetermineZones(source);

		// Determine all macthing destination zones
		List<ComplianceNetworkZone> destinationZones = DetermineZones(destination);

		forbiddenCommunication = new List<(ComplianceNetworkZone, ComplianceNetworkZone)>();

		foreach (ComplianceNetworkZone sourceZone in sourceZones)
		{
			foreach (ComplianceNetworkZone destinationZone in destinationZones)
			{
				if (!sourceZone.CommunicationAllowedTo(destinationZone))
				{
					forbiddenCommunication.Add((sourceZone, destinationZone));
				}
			}
		}

		return forbiddenCommunication.Count == 0;
	}


	private List<ComplianceNetworkZone> DetermineZones(List<IPAddressRange> ranges)
	{
		List<ComplianceNetworkZone> result = new List<ComplianceNetworkZone>();
		List<List<IPAddressRange>> unseenIpAddressRanges = new List<List<IPAddressRange>>();

		for (int i = 0; i < ranges.Count; i++)
		{
			unseenIpAddressRanges.Add(new List<IPAddressRange>()
			{
				new IPAddressRange(ranges[i].Begin, ranges[i].End)
			});
		}

		foreach (ComplianceNetworkZone zone in networkZoneService.NetworkZones)
		{
			if (zone.OverlapExists(ranges, unseenIpAddressRanges))
			{
				result.Add(zone);
			}
		}

		// Get ip ranges that are not in any zone
		List<IPAddressRange> undefinedIpRanges = unseenIpAddressRanges.SelectMany(x => x).ToList();
		if (undefinedIpRanges.Count() > 0)
		{
			result.Add
			(
				new ComplianceNetworkZone()
				{
					Name = "Undefined Zone",
				}
			);
		}

		return result;
	}

	private List<IPAddressRange> ParseIpRange(NetworkObject networkObject)
	{
		List<IPAddressRange> ranges = new List<IPAddressRange>();

		if (networkObject.Type == new NetworkObjectType() { Name = "range" })
		{
			ranges.Add(IPAddressRange.Parse($"{networkObject.IP}-{networkObject.IpEnd}"));
		}
		else if (networkObject.Type != new NetworkObjectType() { Name = "group" })
		{
			for (int j = 0; j < networkObject.ObjectGroupFlats.Length; j++)
			{
				if (networkObject.ObjectGroupFlats[j].Object != null)
				{
					ranges.AddRange(ParseIpRange(networkObject.ObjectGroupFlats[j].Object!));
				}
			}
		}
		else
		{
			// CIDR notation or single (host) IP can be parsed directly
			ranges.Add(IPAddressRange.Parse(networkObject.IP));
		}

		return ranges;
	}
}
